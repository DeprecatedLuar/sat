#!/usr/bin/env bash
# sat - Satellite installer (universal package manager)

SAT_ROOT="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
SAT_LIB="$SAT_ROOT/lib"

source "$SAT_LIB/common.sh"

# ══════════════════════════════════════════════════════════════════════════════
# ──[MANIFEST FUNCTIONS]────────────────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════════════════════
# Internal functions for manifest manipulation. Used by the API.

# sat-manifest (system manifest: tool=source)
_sat_manifest_add()    { sed -i "/^$1=/d" "$SAT_MANIFEST" 2>/dev/null; echo "$1=$2" >> "$SAT_MANIFEST"; }
_sat_manifest_get()    { grep "^$1=" "$SAT_MANIFEST" 2>/dev/null | cut -d= -f2; }
_sat_manifest_remove() { sed -i "/^$1=/d" "$SAT_MANIFEST"; }
_sat_manifest_has()    { grep -q "^$1=" "$SAT_MANIFEST" 2>/dev/null; }

# shell-manifest (master manifest: tool:source:pid)
_shell_manifest_add()        { echo "$1:$2:$3" >> "$SAT_SHELL_MASTER"; }
_shell_manifest_pids()       { grep "^$1:$2:" "$SAT_SHELL_MASTER" 2>/dev/null | cut -d: -f3; }
_shell_manifest_has()        { grep -q "^$1:" "$SAT_SHELL_MASTER" 2>/dev/null; }
_shell_manifest_remove()     { sed -i "\|^$1:$2:$3\$|d" "$SAT_SHELL_MASTER"; }
_shell_manifest_remove_all() { sed -i "\|^$1:|d" "$SAT_SHELL_MASTER"; }
_shell_manifest_promote() {
    local tool="$1" src="$2"
    sed -i "\|^${tool}:${src}:|d" "$SAT_SHELL_MASTER"
    _sat_manifest_has "$tool" || _sat_manifest_add "$tool" "$src"
}

# pid-manifest (session manifest: TOOL=x, SOURCE_x=y)
_pid_manifest_add() {
    local pid="$1" tool="$2" src="$3"
    mkdir -p "$SAT_SHELL_DIR/$pid"
    echo "TOOL=$tool" >> "$SAT_SHELL_DIR/$pid/manifest"
    echo "SOURCE_$tool=$src" >> "$SAT_SHELL_DIR/$pid/manifest"
}
_pid_manifest_tools()  { [[ -f "$SAT_SHELL_DIR/$1/manifest" ]] && grep "^TOOL=" "$SAT_SHELL_DIR/$1/manifest" | cut -d= -f2; }
_pid_manifest_source() { [[ -f "$SAT_SHELL_DIR/$1/manifest" ]] && grep "^SOURCE_$2=" "$SAT_SHELL_DIR/$1/manifest" | cut -d= -f2; }
_pid_manifest_remove() { rm -rf "$SAT_SHELL_DIR/$1" "/tmp/sat-$1" 2>/dev/null; }

# Skip cleanup for internal API calls (prevents recursion)
[[ "$1" != "internal" ]] && cleanup_orphaned_sessions

# ══════════════════════════════════════════════════════════════════════════════
# ──[UNINSTALL]─────────────────────────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════════════════════

sat_uninstall() {
    for PROGRAM in "$@"; do
        SOURCE=$(_sat_manifest_get "$PROGRAM")
        TRACKED=true
        BINARY="$PROGRAM"

        # If not found directly, search by repo name (for gh:user/repo entries)
        if [[ -z "$SOURCE" ]]; then
            local match=$(grep "=gh:.*/${PROGRAM}$" "$SAT_MANIFEST" 2>/dev/null | head -1)
            if [[ -n "$match" ]]; then
                BINARY="${match%%=*}"
                SOURCE="${match#*=}"
            fi
        fi

        if [[ -z "$SOURCE" ]]; then
            if ! command -v "$PROGRAM" &>/dev/null; then
                status "$PROGRAM not found"
                continue
            fi
            SOURCE=$(detect_source "$PROGRAM")
            if [[ -z "$SOURCE" || "$SOURCE" == "unknown" ]]; then
                status "$PROGRAM source unknown, can't remove"
                continue
            fi
            TRACKED=false
        fi

        printf "Removing %s\n" "$BINARY"
        if pkg_remove "$BINARY" "$SOURCE"; then
            [[ "$TRACKED" == true ]] && _sat_manifest_remove "$BINARY"
            status_ok "$BINARY removed" "$SOURCE"
        else
            status_fail "$BINARY removal failed"
        fi
    done
    hash -r
}

# ══════════════════════════════════════════════════════════════════════════════
# ──[LIST]──────────────────────────────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════════════════════

sat_list() {
    local has_content=false

    # Show current session tools (if inside a shell)
    if [[ -n "$SAT_SESSION" && -f "$SAT_SESSION_MANIFEST" ]]; then
        echo "Current session (temporary):"
        while IFS='=' read -r key value; do
            [[ "$key" != "TOOL" ]] && continue
            src=$(grep "^SOURCE_$value=" "$SAT_SESSION_MANIFEST" | cut -d= -f2)
            display=$(source_display "$src")
            color=$(source_color "$display")
            printf "  ${C_DIM}%-20s${C_RESET} [${color}%s${C_RESET}]\n" "$value" "$display"
        done < "$SAT_SESSION_MANIFEST"
        echo ""
        has_content=true
    fi

    # Show active shell tools (from master manifest)
    if [[ -s "$SAT_SHELL_MASTER" ]]; then
        local active_tools=()
        while IFS=: read -r tool src pid; do
            [[ -z "$tool" ]] && continue
            # Only show if PID is alive and not current session
            if kill -0 "$pid" 2>/dev/null && [[ "$pid" != "$SAT_SESSION" ]]; then
                active_tools+=("$tool:$src:$pid")
            fi
        done < "$SAT_SHELL_MASTER"

        if [[ ${#active_tools[@]} -gt 0 ]]; then
            echo "Active shell sessions:"
            for entry in "${active_tools[@]}"; do
                IFS=: read -r tool src pid <<< "$entry"
                display=$(source_display "$src")
                color=$(source_color "$display")
                printf "  ${C_DIM}%-20s${C_RESET} [${color}%s${C_RESET}] ${C_DIM}(pid $pid)${C_RESET}\n" "$tool" "$display"
            done
            echo ""
            has_content=true
        fi
    fi

    # Show system manifest (permanent installs) grouped by source
    if [[ -s "$SAT_MANIFEST" ]]; then
        # Collect entries by normalized source
        declare -A by_source
        declare -a stale=()
        while IFS='=' read -r prog source; do
            [[ -z "$prog" ]] && continue
            if ! command -v "$prog" &>/dev/null; then
                stale+=("$prog")
                continue
            fi
            # Normalize source for grouping (repo:* -> repo, apt/pacman/etc -> system)
            local group="$source"
            case "$source" in
                repo:*) group="repo" ;;
                apt|apk|pacman|dnf|pkg) group="system" ;;
            esac
            by_source[$group]+="$prog=$source"$'\n'
        done < "$SAT_MANIFEST"

        # Print in INSTALL_ORDER, then any remaining
        local printed=()
        for src in "${INSTALL_ORDER[@]}"; do
            [[ -z "${by_source[$src]}" ]] && continue
            while IFS='=' read -r prog source; do
                [[ -z "$prog" ]] && continue
                display=$(source_display "$source")
                color=$(source_color "$display")
                light=$(source_light "$source")
                printf "  ${light}%-20s${C_RESET} [${color}%s${C_RESET}]\n" "$prog" "$display"
            done <<< "${by_source[$src]}"
            printed+=("$src")
        done

        # Print sources not in INSTALL_ORDER (go, manual, unknown, etc)
        for src in "${!by_source[@]}"; do
            [[ " ${printed[*]} " =~ " $src " ]] && continue
            while IFS='=' read -r prog source; do
                [[ -z "$prog" ]] && continue
                display=$(source_display "$source")
                color=$(source_color "$display")
                light=$(source_light "$source")
                printf "  ${light}%-20s${C_RESET} [${color}%s${C_RESET}]\n" "$prog" "$display"
            done <<< "${by_source[$src]}"
        done

        # Clean stale entries
        if [[ ${#stale[@]} -gt 0 ]]; then
            echo ""
            echo "Cleaning ${#stale[@]} stale entries..."
            for prog in "${stale[@]}"; do
                _sat_manifest_remove "$prog"
            done
        fi
        has_content=true
    fi

    [[ "$has_content" == false ]] && echo "No packages tracked by sat"
}

# ══════════════════════════════════════════════════════════════════════════════
# ──[SCAN]──────────────────────────────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════════════════════

sat_scan() {
    echo "Scanning ecosystems..."

    # Detect bin directories dynamically (default first, then actual location)
    local cargo_bin="$HOME/.cargo/bin"
    [[ ! -d "$cargo_bin" ]] && command -v cargo &>/dev/null && cargo_bin="$(dirname "$(command -v cargo)")"

    local npm_bin="$HOME/.npm-global/bin"
    [[ ! -d "$npm_bin" ]] && command -v npm &>/dev/null && npm_bin="$(npm root -g 2>/dev/null)/../bin"

    local go_bin="$HOME/go/bin"
    [[ ! -d "$go_bin" ]] && command -v go &>/dev/null && go_bin="$(go env GOPATH 2>/dev/null)/bin"

    declare -A scan_dirs=(
        ["cargo"]="$cargo_bin"
        ["npm"]="$npm_bin"
        ["uv"]="$HOME/.local/share/uv/tools"
        ["go"]="$go_bin"
    )

    is_from_repo() {
        local bin="$1"
        local real=$(readlink -f "$bin" 2>/dev/null || echo "$bin")
        local dir=$(dirname "$real")
        while [[ "$dir" != "/" && "$dir" != "$HOME" ]]; do
            [[ -d "$dir/.git" ]] && return 0
            dir=$(dirname "$dir")
        done
        return 1
    }

    is_excluded() {
        local prog="$1" src="$2"
        # Global exclusions
        case "$prog" in
            .*|_*|*-config|*-settings) return 0 ;;
        esac
        # Per-source exclusions
        case "$src" in
            cargo) [[ "$prog" == cargo-* || "$prog" == clippy-driver || "$prog" == rust[!u]* || "$prog" == rls ]] && return 0 ;;
            nix)   [[ "$prog" == nix || "$prog" == nix-* ]] && return 0 ;;
            *)     [[ "$prog" == git-* || "$prog" == scalar || "$prog" == trash-* ]] && return 0 ;;
        esac
        return 1
    }

    # Get brew leaves for validation
    local brew_leaves=""
    command -v brew &>/dev/null && brew_leaves=$(brew leaves 2>/dev/null)

    # Prune excluded entries and brew deps from manifest
    local pruned=0
    while IFS='=' read -r prog source; do
        [[ -z "$prog" ]] && continue
        local should_prune=false
        if is_excluded "$prog" "$source"; then
            should_prune=true
        elif [[ "$source" == "brew" && -n "$brew_leaves" ]]; then
            # Prune brew entries not in leaves (deps)
            echo "$brew_leaves" | grep -qxF "$prog" || should_prune=true
        fi
        if $should_prune; then
            _sat_manifest_remove "$prog"
            printf "  ${C_DIM}- %-20s (excluded)${C_RESET}\n" "$prog"
            ((pruned++))
        fi
    done < "$SAT_MANIFEST"

    local added=0

    # Scan directory-based sources
    for src in "${!scan_dirs[@]}"; do
        for dir in ${scan_dirs[$src]}; do
            [[ ! -d "$dir" ]] && continue
            for bin in "$dir"/*; do
                [[ ! -x "$bin" ]] && continue
                prog=$(basename "$bin")
                is_excluded "$prog" "$src" && continue
                [[ -n "$(_sat_manifest_get "$prog")" ]] && continue
                _shell_manifest_has "$prog" && continue
                _sat_manifest_add "$prog" "$src"
                display=$(source_display "$src")
                color=$(source_color "$display")
                printf "  ${color}+${C_RESET} %-20s [${color}%s${C_RESET}]\n" "$prog" "$display"
                ((added++))
            done
        done
    done

    # Homebrew: query explicit installs only (not deps), get actual binary names
    if command -v brew &>/dev/null; then
        while read -r formula; do
            [[ -z "$formula" ]] && continue
            # Get actual binaries installed by this formula
            while read -r bin; do
                [[ -z "$bin" ]] && continue
                prog=$(basename "$bin")
                is_excluded "$prog" "brew" && continue
                [[ -n "$(_sat_manifest_get "$prog")" ]] && continue
                _shell_manifest_has "$prog" && continue
                _sat_manifest_add "$prog" "brew"
                printf "  ${C_BREW}+${C_RESET} %-20s [${C_BREW}brew${C_RESET}]\n" "$prog"
                ((added++))
            done < <(brew list "$formula" 2>/dev/null | grep '/bin/')
        done < <(brew leaves 2>/dev/null)
    fi

    # Nix: scan profile bin but exclude nix-* meta-tools
    if [[ -d "$HOME/.nix-profile/bin" ]]; then
        for bin in "$HOME/.nix-profile/bin"/*; do
            [[ ! -x "$bin" ]] && continue
            prog=$(basename "$bin")
            is_excluded "$prog" "nix" && continue
            [[ -n "$(_sat_manifest_get "$prog")" ]] && continue
            _shell_manifest_has "$prog" && continue
            _sat_manifest_add "$prog" "nix"
            printf "  ${C_NIX}+${C_RESET} %-20s [${C_NIX}nix${C_RESET}]\n" "$prog"
            ((added++))
        done
    fi

    # Local bin: check for repo-sourced tools
    if [[ -d "$HOME/.local/bin" ]]; then
        for bin in "$HOME/.local/bin"/*; do
            [[ ! -x "$bin" ]] && continue
            prog=$(basename "$bin")
            is_excluded "$prog" "repo" && continue
            [[ -n "$(_sat_manifest_get "$prog")" ]] && continue
            _shell_manifest_has "$prog" && continue
            if is_from_repo "$bin"; then
                _sat_manifest_add "$prog" "repo"
                printf "  ${C_REPO}+${C_RESET} %-20s [${C_REPO}repo${C_RESET}]\n" "$prog"
                ((added++))
            fi
        done
    fi

    echo ""
    [[ $pruned -gt 0 ]] && echo "Pruned $pruned excluded entries"
    echo "Added $added packages to manifest"
}

# ══════════════════════════════════════════════════════════════════════════════
# ──[ROUTER]────────────────────────────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════════════════════

case "$1" in
    deps|dependencies)
        echo "Installing sat dependencies..."
        echo ""
        DEPS=(tmux wget curl jq)
        source "$SAT_LIB/install.sh"
        for dep in "${DEPS[@]}"; do
            if command -v "$dep" &>/dev/null; then
                printf "  ${C_CHECK} %s\n" "$dep"
            else
                printf "  Installing %s...\n" "$dep"
                sat_install "$dep:sys"
            fi
        done
        echo ""
        echo "sat is ready to use."
        ;;

    install|i)
        # [[ -z "$2" ]] && { echo "Usage: sat install <program> [--rust|--python|--node|--go|--system]"; exit 1; }
        shift
        source "$SAT_LIB/install.sh"
        sat_install "$@"
        ;;

    search)
        [[ -z "$2" ]] && { echo "Usage: sat search <program> [--wrap]"; exit 1; }
        shift
        source "$SAT_LIB/search.sh"
        sat_search "$@"
        ;;

    uninstall|remove|rm)
        [[ -z "$2" ]] && { echo "Usage: sat uninstall <program> [program2] ..."; exit 1; }
        shift
        sat_uninstall "$@"
        ;;

    shell)
        shift
        source "$SAT_LIB/shell.sh"
        sat_shell "$@"
        ;;

    list|ls)
        sat_list
        ;;

    track)
        [[ -z "$2" ]] && { echo "Usage: sat track <program> [program2] ..."; exit 1; }
        shift
        for prog in "$@"; do
            if [[ -n "$(_sat_manifest_get "$prog")" ]]; then
                echo "$prog: already tracked"
                continue
            fi
            bin=$(command -v "$prog" 2>/dev/null)
            if [[ -z "$bin" ]]; then
                echo "$prog: not found"
                continue
            fi
            src=$(detect_source "$prog")
            [[ -z "$src" || "$src" == "unknown" ]] && { echo "$prog: unknown source, skipping"; continue; }
            _sat_manifest_add "$prog" "$src"
            display=$(source_display "$src")
            color=$(source_color "$display")
            printf "%-20s [${color}%s${C_RESET}] tracked\n" "$prog" "$display"
        done
        ;;

    scan)
        sat_scan
        ;;

    untrack)
        [[ -z "$2" ]] && { echo "Usage: sat untrack <program> [program2] ..."; exit 1; }
        shift
        for prog in "$@"; do
            if [[ -z "$(_sat_manifest_get "$prog")" ]]; then
                echo "$prog: not tracked"
                continue
            fi
            _sat_manifest_remove "$prog"
            echo "$prog: untracked"
        done
        ;;

    source|src)
        [[ -z "$2" ]] && { echo "Usage: sat source <packagemanager>"; exit 1; }
        SOURCE_SCRIPT="$SAT_BASE/packages/sources/$2.sh"
        source <(curl -sSL "$SOURCE_SCRIPT") || { echo "Source '$2' not found"; exit 1; }
        # Try bootstrap function, else _ensure_<name> pattern
        if declare -f bootstrap &>/dev/null; then
            bootstrap
        elif declare -f "_ensure_$2" &>/dev/null; then
            "_ensure_$2"
        fi
        ;;

    clone)
        [[ -z "$2" ]] && { echo "Usage: sat clone <repo> [destination]"; exit 1; }
        REPO="$2"
        DEST="${3:-.}"
        [[ -z "$3" ]] && read -p "Where to clone? (default: ./): " DEST && DEST="${DEST:-.}"
        echo "Cloning $LUAR/$REPO to $DEST..."
        git clone "https://github.com/$LUAR/$REPO.git" "$DEST/$REPO"
        ;;

    info|which|whereis)
        [[ -z "$2" ]] && { echo "Usage: sat info <program> [program2] ..."; exit 1; }
        shift
        for prog in "$@"; do
            bin=$(command -v "$prog" 2>/dev/null)
            if [[ -z "$bin" ]]; then
                echo "$prog: not found"
                continue
            fi
            real=$(readlink -f "$bin" 2>/dev/null || echo "$bin")
            src=$(resolve_source "$prog" "")
            display=$(source_display "$src")
            color=$(source_color "$display")
            tracked=$(_sat_manifest_get "$prog")
            ver=$("$prog" --version 2>/dev/null | head -1 || echo "unknown")

            light=$(source_light "$src")
            printf "${light}%s${C_RESET} [${color}%s${C_RESET}] ${C_DIM}%s${C_RESET}\n" "$prog" "$display" "$ver"
            echo "  path:   $bin"
            [[ "$real" != "$bin" ]] && echo "  target: $real"
            # Show repo for gh:user/repo sources
            [[ "$tracked" == gh:* ]] && echo "  repo:   ${tracked#gh:}"
            [[ -n "$tracked" ]] && echo "  tracked"

            # Show shadowed installations
            all_sources=$(resolve_all_sources "$prog")
            shadowed=$(echo "$all_sources" | grep -v ":active$")
            if [[ -n "$shadowed" ]]; then
                echo "  shadowed:"
                while IFS=: read -r s_src s_path _; do
                    [[ -z "$s_src" ]] && continue
                    s_display=$(source_display "$s_src")
                    s_color=$(source_color "$s_display")
                    printf "    ${C_DIM}[${s_color}%s${C_RESET}${C_DIM}] %s${C_RESET}\n" "$s_display" "$s_path"
                done <<< "$shadowed"
            fi
            [[ $# -gt 1 ]] && echo ""
        done
        ;;

    # ══════════════════════════════════════════════════════════════════════════════
    # ──[INTERNAL API]──────────────────────────────────────────────────────────────
    # ══════════════════════════════════════════════════════════════════════════════
    internal)
        case "$2" in
            sat-manifest)
                case "$3" in
                    add)
                        [[ -z "$4" || -z "$5" ]] && { echo "Usage: sat internal sat-manifest add <tool> <source>"; exit 1; }
                        _sat_manifest_add "$4" "$5"
                        ;;
                    get)
                        [[ -z "$4" ]] && { echo "Usage: sat internal sat-manifest get <tool>"; exit 1; }
                        _sat_manifest_get "$4"
                        ;;
                    remove)
                        [[ -z "$4" ]] && { echo "Usage: sat internal sat-manifest remove <tool>"; exit 1; }
                        _sat_manifest_remove "$4"
                        ;;
                    has)
                        [[ -z "$4" ]] && { echo "Usage: sat internal sat-manifest has <tool>"; exit 1; }
                        _sat_manifest_has "$4"
                        ;;
                    list)
                        [[ -f "$SAT_MANIFEST" ]] && cat "$SAT_MANIFEST"
                        ;;
                    *)
                        echo "Usage: sat internal sat-manifest <add|get|remove|has|list> [args]"; exit 1
                        ;;
                esac
                ;;
            shell-manifest)
                case "$3" in
                    add)
                        [[ -z "$4" || -z "$5" || -z "$6" ]] && { echo "Usage: sat internal shell-manifest add <tool> <source> <pid>"; exit 1; }
                        _shell_manifest_add "$4" "$5" "$6"
                        ;;
                    pids)
                        [[ -z "$4" || -z "$5" ]] && { echo "Usage: sat internal shell-manifest pids <tool> <source>"; exit 1; }
                        _shell_manifest_pids "$4" "$5"
                        ;;
                    has)
                        [[ -z "$4" ]] && { echo "Usage: sat internal shell-manifest has <tool>"; exit 1; }
                        _shell_manifest_has "$4"
                        ;;
                    remove)
                        [[ -z "$4" || -z "$5" || -z "$6" ]] && { echo "Usage: sat internal shell-manifest remove <tool> <source> <pid>"; exit 1; }
                        _shell_manifest_remove "$4" "$5" "$6"
                        ;;
                    remove-all)
                        [[ -z "$4" ]] && { echo "Usage: sat internal shell-manifest remove-all <tool>"; exit 1; }
                        _shell_manifest_remove_all "$4"
                        ;;
                    promote)
                        [[ -z "$4" || -z "$5" ]] && { echo "Usage: sat internal shell-manifest promote <tool> <source>"; exit 1; }
                        _shell_manifest_promote "$4" "$5"
                        ;;
                    list)
                        [[ -f "$SAT_SHELL_MASTER" ]] && cat "$SAT_SHELL_MASTER"
                        ;;
                    *)
                        echo "Usage: sat internal shell-manifest <add|pids|has|remove|remove-all|promote|list> [args]"; exit 1
                        ;;
                esac
                ;;
            pid-manifest)
                case "$3" in
                    add)
                        [[ -z "$4" || -z "$5" || -z "$6" ]] && { echo "Usage: sat internal pid-manifest add <pid> <tool> <source>"; exit 1; }
                        _pid_manifest_add "$4" "$5" "$6"
                        ;;
                    tools)
                        [[ -z "$4" ]] && { echo "Usage: sat internal pid-manifest tools <pid>"; exit 1; }
                        _pid_manifest_tools "$4"
                        ;;
                    source)
                        [[ -z "$4" || -z "$5" ]] && { echo "Usage: sat internal pid-manifest source <pid> <tool>"; exit 1; }
                        _pid_manifest_source "$4" "$5"
                        ;;
                    remove)
                        [[ -z "$4" ]] && { echo "Usage: sat internal pid-manifest remove <pid>"; exit 1; }
                        _pid_manifest_remove "$4"
                        ;;
                    *)
                        echo "Usage: sat internal pid-manifest <add|tools|source|remove> [args]"; exit 1
                        ;;
                esac
                ;;
            *)
                echo "Usage: sat internal <sat-manifest|shell-manifest|pid-manifest> <operation> [args]"; exit 1
                ;;
        esac
        ;;

    help|--help|-h|"")
        cat << 'EOF'
         ,-.
        / \  `.  __..-,O
       :   \ --''_..-'.'
       |    . .-' `. '.
       :     .     .`.'
        \     `.  /  ..
         \      `.   ' .
          `,       `.   \
         ,|,`.        `-.\
        '.||  ``-...__..-`
         |  |
         |__|
         /||\    Usage: sat <command>
        //||\\
       // || \\
    __//__||__\\__
   '--------------'

Commands:
  install|i <pkg>     - Install package(s) with optional source
  source|src <pm>     - Install a package manager (huber, cargo, brew, nix)
  search <program>    - Find package across sources (--all raw, --wrap full)
  uninstall|rm <prog> - Remove program installed via sat
  shell <tool>        - Temp shell with tools, auto-cleanup on exit (requires tmux)
  deps                - Install sat dependencies (tmux, wget, curl, jq)
  info <program>      - Source, path, version, shadowed installs (alias: which)
  list|ls             - List tracked packages (auto-cleans stale entries)
  track <program>     - Add existing program to manifest for sat management
  untrack <program>   - Remove from manifest without uninstalling
  scan                - Scan ecosystem dirs and add all found packages
  clone <repo> [dest] - Clone your repo

Source syntax (install/shell):
  pkg:sys             - System package manager (apt/pacman/etc)
  pkg:brew            - Homebrew
  pkg:nix             - Nix profile
  pkg:rs :rust        - Cargo (Rust)
  pkg:py :python      - uv (Python)
  pkg:js :node        - npm (Node)
  pkg:go              - go install

Examples:
  sat install fd:rs bat:rs ripgrep:rs
  sat shell hyperfine:brew cowsay:sys jq
EOF
        ;;

    *)
        echo "sat: unknown command '$1'" >&2
        exit 1
        ;;
esac
